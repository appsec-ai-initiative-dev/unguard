---
name: Dependabot Critical -> Assign to Copilot (Scheduled)

on:
#  schedule:
#    - cron: "*/30 * * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write
  security-events: read

concurrency:
  group: dependabot-triage
  cancel-in-progress: true

jobs:
  triage-critical:
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App installation token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.AI_APP_ID }}
          private-key: ${{ secrets.AI_APP_PRIVATE_KEY }}
          owner: AppSec-AI-Initiative-Dev
          repositories: |
            unguard

      - name: Cache last run timestamp
        uses: actions/cache@v3
        with:
          path: last-run.txt
          key: dependabot-triage-lastrun-${{ github.run_id }}
          restore-keys: |
            dependabot-triage-lastrun-

      - name: Fetch new Dependabot alerts and create consolidated issue
        uses: actions/github-script@v7
        env:
          COPILOT_SPONSOR_PAT_VALERIY: ${{ secrets.COPILOT_SPONSOR_PAT_VALERIY }}
        with:
          github-token: ${{ steps['app-token'].outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Get last run timestamp
            let lastRunTime = new Date(0);
            const lastRunFile = 'last-run.txt';
            if (fs.existsSync(lastRunFile)) {
              try {
                const lastRunStr = fs.readFileSync(lastRunFile, 'utf8').trim();
                lastRunTime = new Date(lastRunStr);
                core.info(`Last run was at: ${lastRunTime.toISOString()}`);
              } catch (e) {
                core.warning(`Failed to read last run time: ${e.message}`);
              }
            } else {
              core.info('No previous run timestamp found, treating all alerts as new');
            }

            const currentRunTime = new Date();

            async function listAlerts() {
              try {
                const perPage = 100;
                let page = 1;
                let all = [];
                for (;;) {
                  const res = await github.request("GET /repos/{owner}/{repo}/dependabot/alerts", {
                    owner,
                    repo,
                    state: "open",
                    severity: "critical",
                    per_page: perPage,
                    page
                  });
                  all = all.concat(res.data);
                  if (res.data.length < perPage) break;
                  page++;
                }
                return all;
              } catch (e) {
                core.error(`Failed to list Dependabot alerts: ${e.status || ""} ${e.message}`);
                if (e.response?.headers) core.info(`Response headers: ${JSON.stringify(e.response.headers)}`);
                if (e.response?.data) core.info(`Response body: ${JSON.stringify(e.response.data)}`);
                throw e;
              }
            }

            async function consolidatedIssueExists(runMarker) {
              try {
                const q = `repo:${owner}/${repo} is:issue in:body "${runMarker}"`;
                const res = await github.rest.search.issuesAndPullRequests({ q });
                return res.data.total_count > 0;
              } catch (e) {
                core.warning(`Search API failed, proceeding without dedupe: ${e.status || ""} ${e.message}`);
                return false;
              }
            }

            const allAlerts = await listAlerts();
            if (!allAlerts.length) {
              core.info("No open Critical Dependabot alerts found.");
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            // Filter alerts that are new since last run
            const newAlerts = allAlerts.filter(alert => {
              const createdAt = new Date(alert.created_at);
              return createdAt > lastRunTime;
            });

            if (!newAlerts.length) {
              core.info(`Found ${allAlerts.length} total alerts, but no new alerts since ${lastRunTime.toISOString()}`);
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            core.info(`Found ${newAlerts.length} new alert(s) out of ${allAlerts.length} total alerts`);

            const runMarker = `dependabot-alerts-batch: ${currentRunTime.toISOString()}`;

            if (await consolidatedIssueExists(runMarker)) {
              core.info(`Consolidated issue already exists for this run, skipping.`);
              return;
            }

            // Build consolidated issue
            const alertDetails = newAlerts.map(alert => {
              const advisory = alert.security_advisory || {};
              const vuln = alert.security_vulnerability || {};
              const dependency = alert.dependency || {};

              const ghsa =
                advisory.ghsa_id ||
                (advisory.identifiers || []).find(i => i.type === "GHSA")?.value ||
                "N/A";
              const cves = (advisory.identifiers || [])
                .filter(i => i.type === "CVE")
                .map(i => i.value);

              const severity = (advisory.severity || "unknown").toLowerCase();

              const pkg =
                vuln.package?.name ||
                dependency.package?.name ||
                "dependency";
              const ecosystem =
                vuln.package?.ecosystem ||
                dependency.package?.ecosystem ||
                "N/A";

              const affected = vuln.vulnerable_version_range || "N/A";
              const fixedIn = vuln.first_patched_version?.identifier || "N/A";
              const manifest = dependency.manifest_path || "N/A";
              const alertId = alert.number || alert.id;

              const alertUrl =
                alert.html_url ||
                (alertId
                  ? `https://github.com/${owner}/${repo}/security/dependabot/${alertId}`
                  : "N/A");

              return {
                alertId,
                severity,
                ghsa,
                cves,
                pkg,
                ecosystem,
                affected,
                fixedIn,
                manifest,
                alertUrl
              };
            });

            // Sort by severity (should all be critical, but keep for future-proofing)
            alertDetails.sort((a, b) => {
              if (a.severity === 'critical' && b.severity !== 'critical') return -1;
              if (b.severity === 'critical' && a.severity !== 'critical') return 1;
              return a.pkg.localeCompare(b.pkg);
            });

            const criticalCount = alertDetails.length;

            const title = `Dependabot Security Alerts: ${criticalCount} Critical`;

            const alertSections = alertDetails.map(alert => [
              `### ${alert.severity.toUpperCase()}: ${alert.ghsa} in ${alert.pkg}`,
              `- **Alert URL**: ${alert.alertUrl}`,
              `- **Package**: ${alert.pkg} (${alert.ecosystem})`,
              `- **Affected versions**: ${alert.affected}`,
              `- **Fixed in**: ${alert.fixedIn}`,
              `- **GHSA**: ${alert.ghsa}`,
              `- **CVEs**: ${alert.cves.length ? alert.cves.join(", ") : "N/A"}`,
              `- **Manifest path**: ${alert.manifest}`,
              ""
            ].join("\n"));

            const body = [
              `This issue was created automatically for ${newAlerts.length} new Critical Dependabot alert(s) detected on ${currentRunTime.toISOString()}.`,
              "",
              `**Summary**: ${criticalCount} Critical severity alerts`,
              "",
              "## Alert Details",
              "",
              ...alertSections,
              "---",
              "",
              `**Tracking**: ${runMarker}`,
              `**Alert IDs**: ${alertDetails.map(a => a.alertId).join(", ")}`
            ].join("\n");

            // All alerts are critical now
            const overallSeverity = "critical";

            // Names of labels we're adding
            const labelsToAdd = ["security", "dependabot", overallSeverity, "verification:pending"];

            try {
              // Use App token for repo info and issue creation/labeling
              const repoInfo = await github.graphql(
                `query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    id
                    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                      nodes {
                        login
                        __typename
                        ... on Bot { id }
                      }
                    }
                  }
                }`,
                { owner, repo }
              );

              const repositoryId = repoInfo.repository.id;

              // Debug: suggestedActors
              const actors =
                repoInfo?.repository?.suggestedActors?.nodes && Array.isArray(repoInfo.repository.suggestedActors.nodes)
                  ? repoInfo.repository.suggestedActors.nodes
                  : [];
              try {
                core.info("Debug: suggestedActors (CAN_BE_ASSIGNED) count: " + actors.length);
                const preview = actors.slice(0, 25);
                core.info("Debug: suggestedActors preview (first " + preview.length + "): " + JSON.stringify(preview, null, 2));
              } catch (dbgErr) {
                core.warning("Debug: Failed to stringify suggestedActors: " + (dbgErr?.message || String(dbgErr)));
              }

              // Try to pick copilot-swe-agent from suggestedActors (sometimes present)
              let copilotId = null;
              const fromSuggested = actors.find(n => n && n.login === "copilot-swe-agent" && n.id);
              if (fromSuggested?.id) {
                copilotId = fromSuggested.id;
                core.info("Debug: Found copilot-swe-agent in suggestedActors.");
              }

              // Use PAT for Copilot discovery and assignability
              const sponsorToken = process.env.COPILOT_SPONSOR_PAT_VALERIY;
              let sponsor = null;
              if (sponsorToken) {
                sponsor = new github.constructor({ auth: sponsorToken });
                core.info("Sponsor client (PAT) initialized for Copilot discovery/assignment.");
              }

              // If PAT set, use it for Copilot lookup and assignability checks
              if (sponsor) {
                try {
                  const userRes = await sponsor.request("GET /users/{username}", {
                    username: "copilot-swe-agent"
                  });
                  const nodeId = userRes?.data?.node_id;
                  core.info("Debug (PAT): /users/copilot-swe-agent type=" + userRes?.data?.type + " node_id=" + nodeId);

                  // Check if this repo can assign that actor (204 means assignable)
                  let assignable = false;
                  try {
                    const check = await sponsor.request("GET /repos/{owner}/{repo}/assignees/{assignee}", {
                      owner,
                      repo,
                      assignee: "copilot-swe-agent"
                    });
                    if (check.status === 204) {
                      assignable = true;
                      core.info("Debug (PAT): copilot-swe-agent is assignable in this repo (REST check 204).");
                    }
                  } catch (chkErr) {
                    if (chkErr?.status === 404) {
                      core.info("Debug (PAT): copilot-swe-agent is NOT assignable in this repo (REST check 404).");
                    } else {
                      core.warning("Debug (PAT): assignee assignability check failed: " + (chkErr?.message || String(chkErr)));
                    }
                  }

                  if (assignable && nodeId) {
                    copilotId = nodeId;
                    core.info("Debug (PAT): Using node_id from /users as assigneeId.");
                  }
                } catch (userErr) {
                  core.warning("Debug (PAT): GET /users/copilot-swe-agent failed: " + (userErr?.message || String(userErr)));
                }
              }

              // 1. Use App token to create the issue
              const createIssueRes = await github.graphql(
                `mutation($repositoryId: ID!, $title: String!, $body: String!) {
                  createIssue(input: {
                    repositoryId: $repositoryId,
                    title: $title,
                    body: $body
                  }) {
                    issue {
                      number
                      url
                    }
                  }
                }`,
                {
                  repositoryId,
                  title,
                  body
                }
              );
              
              const issueNumber = createIssueRes.createIssue.issue.number;
              
              // 2. Use App token to add labels
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: labelsToAdd
              });
              
              // 3. Use PAT (sponsor) to assign Copilot if possible
              if (sponsor && copilotId) {
                try {
                  await sponsor.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    assignees: ['copilot-swe-agent']
                  });
                  core.info(`Assigned issue #${issueNumber} to copilot-swe-agent (as sponsoring user).`);
                } catch (err) {
                  core.warning(`Could not assign copilot-swe-agent: ${err.message}`);
                  await github.rest.issues.addLabels({
                    owner, repo, issue_number: issueNumber,
                    labels: ["copilot-assignment-failed", "needs-human-sponsor"]
                  });
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: issueNumber,
                    body: "Copilot could not be auto-assigned via API in the sponsor context. Please assign `copilot-swe-agent` from the UI."
                  });
                }
              } else {
                const reason = !sponsor ? "no sponsor PAT configured" : "copilot-swe-agent not found";
                core.warning(`Created consolidated issue #${issueNumber} without Copilot assignment (${reason}).`);
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: issueNumber,
                  labels: ["copilot-assignment-failed", "needs-human-sponsor"]
                });
                await github.rest.issues.createComment({
                  owner, repo, issue_number: issueNumber,
                  body: `Copilot could not be auto-assigned via API (${reason}). Please assign \`copilot-swe-agent\` from the UI.`
                });
              }

            } catch (e) {
              // Fallback path: create without Copilot assignment using the App token, add a label and comment
              if (e.message === "COPILOT_SPONSOR_PAT_MISSING" || e.message === "COPILOT_NOT_ASSIGNABLE" || e.status === 422) {
                const created = await github.rest.issues.create({
                  owner,
                  repo,
                  title,
                  body,
                  labels: ["copilot-assignment-failed", "needs-human-sponsor", ...["security", "dependabot", "critical", "verification:pending"]]
                });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: created.data.number,
                  body: "Automatic assignment to the Copilot coding agent requires a human sponsor token. Please assign `copilot-swe-agent` from the UI, or configure COPILOT_SPONSOR_PAT_VALERIY."
                });
                core.warning(`Copilot assignment unavailable; created issue #${created.data.number} without assignment.`);
              } else if (e.status === 403) {
                core.error(`Issues API denied (403). Verify the GitHub App and/or PAT permissions. Message: ${e.message}`);
                throw e;
              } else {
                core.error(`Issue creation/assignment error: ${e.status || ""} ${e.message}`);
                throw e;
              }
            }

            // Save current timestamp for next run
            fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
            core.info(`Updated last run timestamp to: ${currentRunTime.toISOString()}`)
