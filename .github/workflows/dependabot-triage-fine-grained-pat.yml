name: Dependabot Critical -> Assign to Copilot (Fine-Grained PAT)

on:
#  schedule:
#    - cron: "*/30 * * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write
  security-events: read

concurrency:
  group: dependabot-triage
  cancel-in-progress: true

jobs:
  triage-critical:
    runs-on: ubuntu-latest
    steps:
      - name: Cache last run timestamp
        uses: actions/cache@v3
        with:
          path: last-run.txt
          key: dependabot-triage-lastrun-${{ github.run_id }}
          restore-keys: |
            dependabot-triage-lastrun-

      - name: Fetch new Dependabot critical alerts and create consolidated issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.COPILOT_SPONSOR_PAT_VALERIY }}
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Copilot prompt
            const copilotPrompt = "Verify Dependabot alerts with Dynatrace. For the confirmed ones, apply the fixes. Others should be dismissed.";

            // Get last run timestamp
            let lastRunTime = new Date(0);
            const lastRunFile = 'last-run.txt';
            if (fs.existsSync(lastRunFile)) {
              try {
                const lastRunStr = fs.readFileSync(lastRunFile, 'utf8').trim();
                lastRunTime = new Date(lastRunStr);
                core.info(`Last run was at: ${lastRunTime.toISOString()}`);
              } catch (e) {
                core.warning(`Failed to read last run time: ${e.message}`);
              }
            } else {
              core.info('No previous run timestamp found, treating all alerts as new');
            }

            const currentRunTime = new Date();

            // Uses GitHub's advanced search API for issues/security alerts
            async function listCriticalDependabotAlerts(owner, repo) {
              const perPage = 100;
              let page = 1;
              let all = [];
              for (;;) {
                const q = [
                  `repo:${owner}/${repo}`,
                  `is:issue`,
                  `is:security_alert`,
                  `is:open`,
                  `severity:critical`
                ].join(' ');
                const res = await github.request("GET /search/issues", { q, per_page: perPage, page });
                all = all.concat(res.data.items);
                if (res.data.items.length < perPage) break;
                page++;
              }
              return all;
            }

            async function consolidatedIssueExists(runMarker) {
              try {
                const q = `repo:${owner}/${repo} is:issue in:body "${runMarker}"`;
                const res = await github.request("GET /search/issues", { q });
                return res.data.total_count > 0;
              } catch (e) {
                core.warning(`Search API failed, proceeding without dedupe: ${e.status || ""} ${e.message}`);
                return false;
              }
            }

            const allAlerts = await listCriticalDependabotAlerts(owner, repo);
            if (!allAlerts.length) {
              core.info("No open Critical Dependabot alerts found.");
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            // Filter alerts that are new since last run
            const newAlerts = allAlerts.filter(alert => {
              const createdAt = new Date(alert.created_at);
              return createdAt > lastRunTime;
            });

            if (!newAlerts.length) {
              core.info(`Found ${allAlerts.length} total alerts, but no new alerts since ${lastRunTime.toISOString()}`);
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            core.info(`Found ${newAlerts.length} new critical alert(s) out of ${allAlerts.length} total critical alerts`);

            const runMarker = `dependabot-alerts-batch: ${currentRunTime.toISOString()}`;

            // Check if we already created an issue for this batch
            if (await consolidatedIssueExists(runMarker)) {
              core.info(`Consolidated issue already exists for this run, skipping.`);
              return;
            }

            // Build consolidated issue
            const alertDetails = newAlerts.map(alert => {
              // Advanced search returns issues, so use fields available on issue
              return {
                alertId: alert.number,
                severity: "critical",
                title: alert.title,
                url: alert.html_url,
                createdAt: alert.created_at,
                body: alert.body
              };
            });

            alertDetails.sort((a, b) => a.title.localeCompare(b.title));

            const criticalCount = alertDetails.length;

            const title = `Dependabot Security Alerts: ${criticalCount} Critical`;

            const alertSections = alertDetails.map(alert => [
              `### CRITICAL: Issue #${alert.alertId} - ${alert.title}`,
              `- **Alert URL**: ${alert.url}`,
              `- **Created at**: ${alert.createdAt}`,
              `- **Body**:`,
              alert.body ? alert.body : "",
              ""
            ].join("\n"));

            const body = [
              `**Copilot Instructions:** ${copilotPrompt}`,
              "",
              `This issue was created automatically for ${criticalCount} new Critical Dependabot alert(s) detected on ${currentRunTime.toISOString()}.`,
              "",
              `**Summary**: ${criticalCount} Critical severity alerts`,
              "",
              "## Alert Details",
              "",
              ...alertSections,
              "---",
              "",
              `**Tracking**: ${runMarker}`,
              `**Alert IDs**: ${alertDetails.map(a => a.alertId).join(", ")}`
            ].join("\n");

            const labelsToAdd = ["security", "dependabot", "critical", "verification:pending"];

            try {
              // Find Copilot assignee ID
              const repoInfo = await github.graphql(
                `query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    id
                    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                      nodes {
                        login
                        __typename
                        ... on Bot { id }
                      }
                    }
                  }
                }`,
                { owner, repo }
              );

              const repositoryId = repoInfo.repository.id;
              const actors = (repoInfo &&
                              repoInfo.repository &&
                              repoInfo.repository.suggestedActors &&
                              Array.isArray(repoInfo.repository.suggestedActors.nodes))
                                ? repoInfo.repository.suggestedActors.nodes
                                : [];
              let copilotId = null;
              const fromSuggested = actors.find(n => n && n.login === "copilot-swe-agent" && n.id);
              if (fromSuggested && fromSuggested.id) {
                copilotId = fromSuggested.id;
              } else {
                try {
                  const userRes = await github.request("GET /users/{username}", {
                    username: "copilot-swe-agent"
                  });
                  const nodeId = userRes && userRes.data ? userRes.data.node_id : null;
                  let assignable = false;
                  try {
                    const check = await github.request("GET /repos/{owner}/{repo}/assignees/{assignee}", {
                      owner,
                      repo,
                      assignee: "copilot-swe-agent"
                    });
                    if (check.status === 204) {
                      assignable = true;
                    }
                  } catch (chkErr) {}
                  if (assignable && nodeId) {
                    copilotId = nodeId;
                  }
                } catch (userErr) {}
              }

              if (!copilotId) {
                throw new Error("COPILOT_NOT_ASSIGNABLE");
              }

              // Create the issue using GraphQL with Copilot assigned
              const createIssueRes = await github.graphql(
                `mutation($repositoryId: ID!, $title: String!, $body: String!, $assigneeIds: [ID!]) {
                  createIssue(input: {
                    repositoryId: $repositoryId,
                    title: $title,
                    body: $body,
                    assigneeIds: $assigneeIds
                  }) {
                    issue {
                      number
                      url
                    }
                  }
                }`,
                {
                  repositoryId,
                  title,
                  body,
                  assigneeIds: [copilotId]
                }
              );

              const issueNumber = createIssueRes.createIssue.issue.number;

              // Add labels via REST
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: labelsToAdd
              });

              core.info(`Created consolidated issue #${issueNumber} and assigned to copilot-swe-agent via assigneeIds`);

            } catch (e) {
              // Fallback path: create without Copilot assignment, add a label and comment
              if (e.message === "COPILOT_NOT_ASSIGNABLE" || e.status === 422) {
                const created = await github.rest.issues.create({
                  owner,
                  repo,
                  title,
                  body,
                  labels: [...labelsToAdd, "copilot-assignment-failed"]
                });
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: created.data.number,
                  body: "Automatic assignment to the Copilot coding agent (copilot-swe-agent) could not be completed. Ensure the agent is enabled for this repository and that this GitHub token can assign it (it should appear in the repo Assignees REST check)."
                });
                core.warning(`Copilot assignment unavailable; created issue #${created.data.number} with fallback label.`);
              } else if (e.status === 403) {
                core.error(`Issues API denied (403). Verify the personal access token has 'Issues: Read and write' and is allowed for this repository. Message: ${e.message}`);
                throw e;
              } else {
                core.error(`Issue creation/assignment error: ${e.status || ""} ${e.message}`);
                throw e;
              }
            }

            // Save current timestamp for next run
            fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
            core.info(`Updated last run timestamp to: ${currentRunTime.toISOString()}`)
