name: Dependabot Critical -> Assign to Copilot (Fine-grained-PAT)

on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write
  security-events: read

concurrency:
  group: dependabot-triage
  cancel-in-progress: true

jobs:
  triage-critical:
    runs-on: ubuntu-latest
    steps:
      - name: Cache last run timestamp
        uses: actions/cache@v3
        with:
          path: last-run.txt
          key: dependabot-triage-lastrun-${{ github.run_id }}
          restore-keys: |
            dependabot-triage-lastrun-

      - name: Fetch new Dependabot critical alerts and create consolidated issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_SPONSOR_PAT }}
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const copilotPrompt = "Verify Dependabot alerts with Dynatrace. For the confirmed ones, apply the fixes. Others should be dismissed.";

            let lastRunTime = new Date(0);
            const lastRunFile = 'last-run.txt';
            if (fs.existsSync(lastRunFile)) {
              try {
                const lastRunStr = fs.readFileSync(lastRunFile, 'utf8').trim();
                lastRunTime = new Date(lastRunStr);
                core.info(`Last run was at: ${lastRunTime.toISOString()}`);
              } catch (e) {
                core.warning(`Failed to read last run time: ${e.message}`);
              }
            } else {
              core.info('No previous run timestamp found, treating all alerts as new');
            }

            const currentRunTime = new Date();

            // FIXED: No page parameter - single API call, set per_page to max 1000
            async function listCriticalDependabotAlerts(owner, repo) {
              const perPage = 1000;
              const res = await github.request("GET /repos/{owner}/{repo}/dependabot/alerts", {
                owner,
                repo,
                state: "open",
                severity: "critical",
                per_page: perPage
              });
              return res.data;
            }

            async function consolidatedIssueExists(runMarker) {
              // List open issues with expected labels, and check for marker in body
              const perPage = 100;
              let page = 1;
              let found = false;
              while (!found) {
                const issuesResp = await github.request("GET /repos/{owner}/{repo}/issues", {
                  owner,
                  repo,
                  state: "open",
                  labels: "security,dependabot,critical,verification:pending",
                  per_page: perPage,
                  page
                });
                if (!issuesResp.data.length) break;
                for (const issue of issuesResp.data) {
                  if (issue.body && issue.body.includes(runMarker)) {
                    found = true;
                    break;
                  }
                }
                if (issuesResp.data.length < perPage) break;
                page++;
              }
              return found;
            }

            const allAlerts = await listCriticalDependabotAlerts(owner, repo);
            if (!allAlerts.length) {
              core.info("No open Critical Dependabot alerts found.");
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            const newAlerts = allAlerts.filter(alert => {
              const createdAt = new Date(alert.created_at);
              return createdAt > lastRunTime;
            });

            if (!newAlerts.length) {
              core.info(`Found ${allAlerts.length} total alerts, but no new alerts since ${lastRunTime.toISOString()}`);
              fs.writeFileSync(lastRunFile, currentRunTime.toISOString());
              return;
            }

            core.info(`Found ${newAlerts.length} new critical alert(s) out of ${allAlerts.length} total critical alerts`);

            const runMarker = `dependabot-alerts-batch: ${currentRunTime.toISOString()}`;

            if (await consolidatedIssueExists(runMarker)) {
              core.info(`Consolidated issue already exists for this run, skipping.`);
              return;
            }

            const alertDetails = newAlerts.map(alert => {
              const advisory = alert.security_advisory || {};
              const vuln = alert.security_vulnerability || {};
              const dependency = alert.dependency || {};

              const ghsa =
                advisory.ghsa_id ||
                (advisory.identifiers || []).find(i => i.type === "GHSA")?.value ||
                "N/A";
              const cves = (advisory.identifiers || [])
                .filter(i => i.type === "CVE")
                .map(i => i.value);

              const severity = (advisory.severity || "unknown").toLowerCase();

              const pkg =
                vuln.package?.name ||
                dependency.package?.name ||
                "dependency";
              const ecosystem =
                vuln.package?.ecosystem ||
                dependency.package?.ecosystem ||
                "N/A";

              const affected = vuln.vulnerable_version_range || "N/A";
              const fixedIn = vuln.first_patched_version?.identifier || "N/A";
              const manifest = dependency.manifest_path || "N/A";
              const alertId = alert.number || alert.id;

              const alertUrl =
                alert.html_url ||
                (alertId
                  ? `https://github.com/${owner}/${repo}/security/dependabot/${alertId}`
                  : "N/A");

              return {
                alertId,
                severity,
                ghsa,
                cves,
                pkg,
                ecosystem,
                affected,
                fixedIn,
                manifest,
                alertUrl
              };
            });

            alertDetails.sort((a, b) => a.pkg.localeCompare(b.pkg));
            const criticalCount = alertDetails.length;

            const title = `Dependabot Security Alerts: ${criticalCount} Critical`;

            const alertSections = alertDetails.map(alert => [
              `### CRITICAL: ${alert.ghsa} in ${alert.pkg}`,
              `- **Alert URL**: ${alert.alertUrl}`,
              `- **Package**: ${alert.pkg} (${alert.ecosystem})`,
              `- **Affected versions**: ${alert.affected}`,
              `- **Fixed in**: ${alert.fixedIn}`,
              `- **GHSA**: ${alert.ghsa}`,
              `- **CVEs**: ${alert.cves.length ? alert.cves.join(", ") : "N/A"}`,
              `- **Manifest path**: ${alert.manifest}`,
              ""
            ].join("\n"));

            const body = [
              `**Copilot Instructions:** ${copilotPrompt}`,
              "",
              `This issue was created automatically for ${criticalCount} new Critical Dependabot alert(s) detected on ${currentRunTime.toISOString()}.`,
              "",
              `**Summary**: ${criticalCount} Critical severity alerts`,
              "",
              "## Alert Details",
              "",
              ...alertSections,
              "---",
              "",
              `**Tracking**: ${runMarker}`,
              `**Alert IDs**: ${alertDetails.map(a => a.alertId).join(", ")}`
            ].join("\n");

            const labelsToAdd = ["security", "dependabot", "critical", "verification:pending"];

            try {
              // Find Copilot assignee ID as before
              const repoInfo = await github.graphql(
                `query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    id
                    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
                      nodes {
                        login
                        __typename
                        ... on Bot { id }
                      }
                    }
                  }
                }`,
                { owner, repo }
              );
              const repositoryId = repoInfo.repository.id;
              const actors = repoInfo.repository.suggestedActors?.nodes || [];
              let cop
